# Mejores prÃ¡cticas de codificaciÃ³n para el backend

A continuaciÃ³n se presentan las mejores prÃ¡cticas de codificaciÃ³n para el backend.

## Tabla de contenidos

- [Mejores prÃ¡cticas de codificaciÃ³n para el backend](#mejores-prÃ¡cticas-de-codificaciÃ³n-para-el-backend)
- [Nomenclatura](#nomenclatura)
- [Carpetas](#carpetas)
- [Controladores](#controladores)
  - [DocumentaciÃ³n de controladores](#documentaciÃ³n-de-controladores)
- [Servicios](#servicios)
- [Constantes](#constantes)
- [DTOs](#dtos)
  - [DocumentaciÃ³n de los DTOs](#documentaciÃ³n-de-dtos)
  - [Validando los DTOs](#validando-los-dtos)
- [Entidades](#entidades)
- [Helpers](#helpers)
- [Tipos de respuestas](#tipos-de-respuestas)
- [Enumeraciones](#enumeraciones)
- [Errores y excepciones](#errores-y-excepciones)
- [Estructura de carpetas](#estructura-de-carpetas)

Las convenciones de codificaciÃ³n que se describen a continuaciÃ³n son las que se deben seguir al escribir cÃ³digo en este repositorio. Si estÃ¡s trabajando en un proyecto diferente, es posible que las convenciones de codificaciÃ³n sean diferentes. Por favor, consulta con el lÃ­der de proyecto para conocer las convenciones de codificaciÃ³n que se deben seguir en tu proyecto.

Las siguientes reglas aplicarÃ¡n para el nombramiento de variables, funciones, interfaces, enumeraciones, propiedades, constantes, parÃ¡metros y tipos.

- Los nombres deben ser descriptivos y deben nombrarse de forma que su nombre describa su propÃ³sito.
- Los nombres deben ser en inglÃ©s.
- Evitar el acortado de nombres no importa que tan largos sean.
- Evitar el uso de tipos como any, unknown, etc. (Solo en casos excepcionales).
- Evitar el uso de cÃ³digo comentado (A excepciÃ³n de que sea necesario para explicar el funcionamiento de una parte del cÃ³digo).
- Si es necesario comentar el funcionamiento de una parte del cÃ³digo puedes hacerlo en espaÃ±ol o inglÃ©s.
- Evitar el uso de magic string o magic number.

## Nomenclatura

La nomenclarura es una parte importante de la codificaciÃ³n, ya que permite que el cÃ³digo sea mÃ¡s legible y fÃ¡cil de entender. A continuaciÃ³n se describen las reglas de nomenclatura que se deben seguir al escribir cÃ³digo en este repositorio.

> **A continuaciÃ³n hablaremos de diferentes tipo de nomenclaturas**, para mÃ¡s informaciÃ³n revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

- **Archivos**: Los nombres de los archivos deben ser en kebab-case, es decir, todas las letras en minÃºscula y separadas por guiones. Por ejemplo, `my-file-name.ts`.
- **Carpetas**: Los nombres de las carpetas deben ser en kebab-case, es decir, todas las letras en minÃºscula y separadas por guiones. Por ejemplo, `my-folder-name`.
- **Variables**: Los nombres de las variables deben ser en camelCase, es decir, la primera letra en minÃºscula y las siguientes palabras en mayÃºscula. Por ejemplo, `myVariableName`.
- **Funciones**: Los nombres de las funciones deben ser en camelCase, es decir, la primera letra en minÃºscula y las siguientes palabras en mayÃºscula. Por ejemplo, `myFunctionName`.

## Carpetas

Las carpetas deben contener archivos relacionados entre sÃ­. Por ejemplo, una carpeta `helpers` solo debe contener funciones que nos brinden ayuda en diferentes partes de nuestra aplicaciÃ³n, una carpeta `services` solo debe contener los servicios de nuestra aplicaciÃ³n, etc.

## Controladores

Los controladores nos permiten manejar las peticiones HTTP y devolver una respuesta al cliente. Gracias a los controladores, podemos separar la lÃ³gica de negocio de la lÃ³gica de presentaciÃ³n. A continuaciÃ³n, se presentan algunas recomendaciones para escribir controladores:

- **Evitar la lÃ³gica de negocio en los controladores**: Los controladores deben ser lo mÃ¡s simples posible. La lÃ³gica de negocio debe estar en los servicios.
- **Usar DTOs**: Los DTOs nos permiten definir la estructura de los datos que se envÃ­an y reciben en las peticiones HTTP.
- **Solo deben tener una peticiÃ³n por mÃ©todo**: Cada mÃ©todo de un controlador debe tener una Ãºnica peticiÃ³n HTTP (GET, POST, PUT, DELETE, etc.).
- **Usar el decorador `@Controller`**: El decorador `@Controller` de NestJS nos permite definir un controlador.
- **Usar el decorador `@Get`, `@Post`, `@Put`, `@Delete`**: Estos decoradores nos permiten definir las rutas de los mÃ©todos de un controlador.
- **Debemos tipar el retorno de los mÃ©todos**: Es importante tipar el retorno de los mÃ©todos de un controlador para facilitar la generaciÃ³n de los endpoint en el frontend.

Para obtener informaciÃ³n utilizaremos la siguiente nomenglatura:

- `findOne`: Obtener un recurso por su id.
- `findAll`: Obtener todos los recursos.
- `create`: Crear un recurso.
- `update`: Actualizar un recurso.
- `remove`: Eliminar un recurso.

### DocumentaciÃ³n de controladores

> **Nota**: Swagger es una herramienta que nos permite documentar nuestra API de forma sencilla, nos permite definir los endpoints, los mÃ©todos HTTP, los parÃ¡metros, las respuestas, etc. Para mÃ¡s informaciÃ³n sobre decoradores de Swagger, puedes consultar la [documentaciÃ³n oficial](https://docs.nestjs.com/openapi/decorators).

Una buena documentaciÃ³n es fundamental para que los desarrolladores puedan entender cÃ³mo funciona nuestra API sin necesidad de leer el cÃ³digo. A continuaciÃ³n, se presentan algunos decoradores de Swagger que nos permiten documentar los controladores:

- `@ApiTags`: Este decorador nos permite definir las etiquetas de la documentaciÃ³n y su uso es obligatorio.
- `@ApiOperation`: Este decorador nos permite definir la descripciÃ³n de un endpoint y su uso es obligatorio.
- `@ApiParam`: Este decorador nos permite definir los parÃ¡metros de un endpoint y su uso es obligatorio.
- `@ApiBody`: Este decorador nos permite definir el cuerpo de una peticiÃ³n y su uso es opcional, se recomiendo para este caso documentar directamente el DTO.
- `@ApiResponse`: Este decorador nos permite definir las respuestas de un endpoint y su uso es opcional.

## Servicios

Los servicios nos permiten encapsular la lÃ³gica de negocio de nuestra aplicaciÃ³n. Gracias a los servicios, podemos reutilizar la lÃ³gica de negocio en diferentes partes de nuestra aplicaciÃ³n. A continuaciÃ³n, ademÃ¡s de permitirnos obtener datos de la base de datos. A continuaciÃ³n se presentan algunas recomendaciones para escribir servicios:

- **Los servicios deben ser lo mÃ¡s simples posibles**: Cada servicio debe tener una Ãºnica responsabilidad.
- **Usar DTOs**: Los DTOs nos permiten definir la estructura de los datos que se envÃ­an y reciben en las peticiones HTTP.
- **Solo mostrar la informaciÃ³n necesaria**: Los servicios deben devolver solo la informaciÃ³n necesaria para el cliente.
- **Dentro de los servicios no se deben hacer peticiones HTTP**: Las peticiones HTTP deben hacerse en los controladores.
- **Se debe crear un DTO para cada servicio**: Cada servicio debe tener un DTO que defina la estructura de los datos que se envÃ­an y reciben, no importa si el servicio solo recibe un parÃ¡metro.
- **Cuando se necesita sacar informaciÃ³n del token, se debe sacar informaciÃ³n de la request**: No se debe sacar informaciÃ³n del token dentro de los servicios, se debe sacar la informaciÃ³n del token desde la request. Esta es la Ãºnica excepciÃ³n en la que un servicio recibe dos parÃ¡metros, por un lado el DTO y por otro lado la request.

## Constantes

Las constantes nos permiten definir valores que no cambian a lo largo de la ejecuciÃ³n de nuestra aplicaciÃ³n.

> **Es importante tener en cuenta que las constantes deben ser nombradas siguiendo la convenciÃ³n de snake_case y en mayÃºsculas**, para mÃ¡s informaciÃ³n revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

```ts
// Error âŒ
const myConstant = 'value'

// Correcto âœ…
const MY_CONSTANT = 'value'
```

## DTOs

Los DTOs son las interfaces que representan los modelos de datos que reciben los servicios, gracias a los DTOs podemos definir la estructura de los datos que se envÃ­an y reciben en las peticiones HTTP. A continuaciÃ³n, se presentan algunas recomendaciones para escribir DTOs:

Se debe seguir una serie de reglas a la hora de nombrar los DTOs:

- Se debe empezar por el nombre del servicio al que pertenece el DTO.
- Se debe terminar con la palabra `Dto`.

```ts
export class MyServiceDto {
  ...
}
```

> **Es importante tener en cuenta que los dtos deben ser nombrados siguiendo la convenciÃ³n de PascalCase**, para mÃ¡s informaciÃ³n revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

### DocumentaciÃ³n de DTOs

> **Nota**: Swagger es una herramienta que nos permite documentar nuestra API de forma sencilla, nos permite definir los endpoints, los mÃ©todos HTTP, los parÃ¡metros, las respuestas, etc. Para mÃ¡s informaciÃ³n sobre decoradores de Swagger, puedes consultar la [documentaciÃ³n oficial](https://docs.nestjs.com/openapi/decorators).

Documentar los DTOs es fundamental para que los desarrolladores puedan entender que datos se envÃ­an y reciben en las peticiones HTTP asÃ­ como el tipo de dato. A continuaciÃ³n, se presentan algunos decoradores de Swagger que nos permiten documentar los DTOs:

- `@ApiProperty`: Este decorador nos permite definir la descripciÃ³n de una propiedad y su uso es obligatorio, de este decorador no nos interesa la propiedad `example`.

### Validando los DTOs

> **Nota**: Class-validator es una librerÃ­a que nos permite validar los datos de un objeto. Para mÃ¡s informaciÃ³n sobre class-validator, puedes consultar la [documentaciÃ³n oficial](https://github.com/typestack/class-validator?tab=readme-ov-file#validation-decorators).

Validar los DTOs es fundamental para garantizar que los datos que se envÃ­an y reciben en las peticiones HTTP son correctos. Es importante agregar la cantidad de validaciones necesarias para garantizar que los datos son correctos.

## Entidades

Las entidades son las clases que representan los modelos de datos en la base de datos. A continuaciÃ³n, se presentan algunas recomendaciones para escribir entidades:

- **Usar el decorador `@Entity`**: El decorador `@Entity` de TypeORM nos permite definir una entidad.
- **Usar el decorador `@PrimaryGeneratedColumn`**: El decorador `@PrimaryGeneratedColumn` de TypeORM nos permite definir una columna autoincremental. Si es posible utilizar UUID en lugar de autoincremental.
- **Usar el decorador `@Column`**: El decorador `@Column` de TypeORM nos permite definir una columna.
- **Usar el decorador `@CreateDateColumn`**: El decorador `@CreateDateColumn` de TypeORM nos permite definir una columna que se actualiza automÃ¡ticamente con la fecha de creaciÃ³n.
- **Usar el decorador `@UpdateDateColumn`**: El decorador `@UpdateDateColumn` de TypeORM nos permite definir una columna que se actualiza automÃ¡ticamente con la fecha de actualizaciÃ³n.

## Helpers

Los helpers son funciones que nos permiten reutilizar la lÃ³gica de negocio en diferentes partes de nuestra aplicaciÃ³n. Por lo general son funciones que no dependen de una clase o mÃ³dulo en particular y nos ayudan con validaciones, formateo de datos, etc.

## Tipos de respuestas

Los tipos de respuestas nos permiten definir la estructura de los datos que se devuelves en las peticiones HTTP, ademÃ¡s, nos permmite generar los endpoint en el frontend de forma automÃ¡tica. Por lo general, los tipos de respuestas son entidades.

> **Es importante tener en cuenta que los tipos de respuestas deben ser nombrados siguiendo la convenciÃ³n de PascalCase**, para mÃ¡s informaciÃ³n revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

## Enumeraciones

Las enumeraciones nos permiten definir un conjunto de constantes con nombre.

> **Es importante tener en cuenta que tanto el nombre de las enumeraciones como los atributos deben ser nombradas siguiendo la convenciÃ³n de PascalCase**, para mÃ¡s informaciÃ³n revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

## Errores y excepciones

Los errores y excepciones nos permiten manejar los errores de nuestra aplicaciÃ³n de forma eficiente Nos apoyaremos de los cÃ³digos de estado HTTP para devolver la informaciÃ³n necesaria al cliente. Para ejecutar una excepciÃ³n en NestJS, podemos hacer uso de la clase `HttpException`, la cual recibe dos parÃ¡metros, el mensaje de error y el cÃ³digo de estado HTTP.

- El mensaje de error debemos utilizarlo en una constante.
- Para el cÃ³digo de estado HTTP debemos hacer uso de `HttpStatus`.

```ts
// Error âŒ
throw new HttpException('Error', 400)

// Correcto âœ…
throw new HttpException(MY_CONSTANT, HttpStatus.BAD_REQUEST)
```

## Estructura de carpetas

La estructura de carpetas nos permite organizar nuestro cÃ³digo de forma eficiente. A continuaciÃ³n, se presenta una estructura de carpetas recomendada para escribir una aplicaciÃ³n en NestJS:

```bash
â””â”€â”€ ğŸ“src
    â”œâ”€â”€ ğŸ“decorators
    â”œâ”€â”€ ğŸ“filters
    â”œâ”€â”€ ğŸ“helpers
    â”œâ”€â”€ ğŸ“interceptors
    â”œâ”€â”€ ğŸ“middlewares
    â”œâ”€â”€ ğŸ“modules
    â”‚   â”œâ”€â”€ ğŸ“my-module
    â”‚   â”‚   â”œâ”€â”€ ğŸ“dtos
    â”‚   â”‚   â”œâ”€â”€ ğŸ“entities
    â”‚   â”‚   â”œâ”€â”€ ğŸ“enums
    â”‚   â”‚   â”œâ”€â”€ ğŸ“return-types
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„my-module.controller.ts
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„my-module.module.ts
    â”‚   â”‚   â””â”€â”€ ğŸ“„my-module.service.ts
    â”‚   â”œâ”€â”€ ğŸ“„app.module.ts
    â”‚   â””â”€â”€ ğŸ“„main.ts
```




