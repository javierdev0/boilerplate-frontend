# Mejores prácticas de codificación para el backend

A continuación se presentan las mejores prácticas de codificación para el backend.

## Tabla de contenidos

- [Mejores prácticas de codificación para el backend](#mejores-prácticas-de-codificación-para-el-backend)
- [Nomenclatura](#nomenclatura)
- [Carpetas](#carpetas)
- [Controladores](#controladores)
  - [Documentación de controladores](#documentación-de-controladores)
- [Servicios](#servicios)
- [Constantes](#constantes)
- [DTOs](#dtos)
  - [Documentación de los DTOs](#documentación-de-dtos)
  - [Validando los DTOs](#validando-los-dtos)
- [Entidades](#entidades)
- [Helpers](#helpers)
- [Tipos de respuestas](#tipos-de-respuestas)
- [Enumeraciones](#enumeraciones)
- [Errores y excepciones](#errores-y-excepciones)
- [Estructura de carpetas](#estructura-de-carpetas)

Las convenciones de codificación que se describen a continuación son las que se deben seguir al escribir código en este repositorio. Si estás trabajando en un proyecto diferente, es posible que las convenciones de codificación sean diferentes. Por favor, consulta con el líder de proyecto para conocer las convenciones de codificación que se deben seguir en tu proyecto.

Las siguientes reglas aplicarán para el nombramiento de variables, funciones, interfaces, enumeraciones, propiedades, constantes, parámetros y tipos.

- Los nombres deben ser descriptivos y deben nombrarse de forma que su nombre describa su propósito.
- Los nombres deben ser en inglés.
- Evitar el acortado de nombres no importa que tan largos sean.
- Evitar el uso de tipos como any, unknown, etc. (Solo en casos excepcionales).
- Evitar el uso de código comentado (A excepción de que sea necesario para explicar el funcionamiento de una parte del código).
- Si es necesario comentar el funcionamiento de una parte del código puedes hacerlo en español o inglés.
- Evitar el uso de magic string o magic number.

## Nomenclatura

La nomenclarura es una parte importante de la codificación, ya que permite que el código sea más legible y fácil de entender. A continuación se describen las reglas de nomenclatura que se deben seguir al escribir código en este repositorio.

> **A continuación hablaremos de diferentes tipo de nomenclaturas**, para más información revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

- **Archivos**: Los nombres de los archivos deben ser en kebab-case, es decir, todas las letras en minúscula y separadas por guiones. Por ejemplo, `my-file-name.ts`.
- **Carpetas**: Los nombres de las carpetas deben ser en kebab-case, es decir, todas las letras en minúscula y separadas por guiones. Por ejemplo, `my-folder-name`.
- **Variables**: Los nombres de las variables deben ser en camelCase, es decir, la primera letra en minúscula y las siguientes palabras en mayúscula. Por ejemplo, `myVariableName`.
- **Funciones**: Los nombres de las funciones deben ser en camelCase, es decir, la primera letra en minúscula y las siguientes palabras en mayúscula. Por ejemplo, `myFunctionName`.

## Carpetas

Las carpetas deben contener archivos relacionados entre sí. Por ejemplo, una carpeta `helpers` solo debe contener funciones que nos brinden ayuda en diferentes partes de nuestra aplicación, una carpeta `services` solo debe contener los servicios de nuestra aplicación, etc.

## Controladores

Los controladores nos permiten manejar las peticiones HTTP y devolver una respuesta al cliente. Gracias a los controladores, podemos separar la lógica de negocio de la lógica de presentación. A continuación, se presentan algunas recomendaciones para escribir controladores:

- **Evitar la lógica de negocio en los controladores**: Los controladores deben ser lo más simples posible. La lógica de negocio debe estar en los servicios.
- **Usar DTOs**: Los DTOs nos permiten definir la estructura de los datos que se envían y reciben en las peticiones HTTP.
- **Solo deben tener una petición por método**: Cada método de un controlador debe tener una única petición HTTP (GET, POST, PUT, DELETE, etc.).
- **Usar el decorador `@Controller`**: El decorador `@Controller` de NestJS nos permite definir un controlador.
- **Usar el decorador `@Get`, `@Post`, `@Put`, `@Delete`**: Estos decoradores nos permiten definir las rutas de los métodos de un controlador.
- **Debemos tipar el retorno de los métodos**: Es importante tipar el retorno de los métodos de un controlador para facilitar la generación de los endpoint en el frontend.

Para obtener información utilizaremos la siguiente nomenglatura:

- `findOne`: Obtener un recurso por su id.
- `findAll`: Obtener todos los recursos.
- `create`: Crear un recurso.
- `update`: Actualizar un recurso.
- `remove`: Eliminar un recurso.

### Documentación de controladores

> **Nota**: Swagger es una herramienta que nos permite documentar nuestra API de forma sencilla, nos permite definir los endpoints, los métodos HTTP, los parámetros, las respuestas, etc. Para más información sobre decoradores de Swagger, puedes consultar la [documentación oficial](https://docs.nestjs.com/openapi/decorators).

Una buena documentación es fundamental para que los desarrolladores puedan entender cómo funciona nuestra API sin necesidad de leer el código. A continuación, se presentan algunos decoradores de Swagger que nos permiten documentar los controladores:

- `@ApiTags`: Este decorador nos permite definir las etiquetas de la documentación y su uso es obligatorio.
- `@ApiOperation`: Este decorador nos permite definir la descripción de un endpoint y su uso es obligatorio.
- `@ApiParam`: Este decorador nos permite definir los parámetros de un endpoint y su uso es obligatorio.
- `@ApiBody`: Este decorador nos permite definir el cuerpo de una petición y su uso es opcional, se recomiendo para este caso documentar directamente el DTO.
- `@ApiResponse`: Este decorador nos permite definir las respuestas de un endpoint y su uso es opcional.

## Servicios

Los servicios nos permiten encapsular la lógica de negocio de nuestra aplicación. Gracias a los servicios, podemos reutilizar la lógica de negocio en diferentes partes de nuestra aplicación. A continuación, además de permitirnos obtener datos de la base de datos. A continuación se presentan algunas recomendaciones para escribir servicios:

- **Los servicios deben ser lo más simples posibles**: Cada servicio debe tener una única responsabilidad.
- **Usar DTOs**: Los DTOs nos permiten definir la estructura de los datos que se envían y reciben en las peticiones HTTP.
- **Solo mostrar la información necesaria**: Los servicios deben devolver solo la información necesaria para el cliente.
- **Dentro de los servicios no se deben hacer peticiones HTTP**: Las peticiones HTTP deben hacerse en los controladores.
- **Se debe crear un DTO para cada servicio**: Cada servicio debe tener un DTO que defina la estructura de los datos que se envían y reciben, no importa si el servicio solo recibe un parámetro.
- **Cuando se necesita sacar información del token, se debe sacar información de la request**: No se debe sacar información del token dentro de los servicios, se debe sacar la información del token desde la request. Esta es la única excepción en la que un servicio recibe dos parámetros, por un lado el DTO y por otro lado la request.

## Constantes

Las constantes nos permiten definir valores que no cambian a lo largo de la ejecución de nuestra aplicación.

> **Es importante tener en cuenta que las constantes deben ser nombradas siguiendo la convención de snake_case y en mayúsculas**, para más información revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

```ts
// Error ❌
const myConstant = 'value'

// Correcto ✅
const MY_CONSTANT = 'value'
```

## DTOs

Los DTOs son las interfaces que representan los modelos de datos que reciben los servicios, gracias a los DTOs podemos definir la estructura de los datos que se envían y reciben en las peticiones HTTP. A continuación, se presentan algunas recomendaciones para escribir DTOs:

Se debe seguir una serie de reglas a la hora de nombrar los DTOs:

- Se debe empezar por el nombre del servicio al que pertenece el DTO.
- Se debe terminar con la palabra `Dto`.

```ts
export class MyServiceDto {
  ...
}
```

> **Es importante tener en cuenta que los dtos deben ser nombrados siguiendo la convención de PascalCase**, para más información revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

### Documentación de DTOs

> **Nota**: Swagger es una herramienta que nos permite documentar nuestra API de forma sencilla, nos permite definir los endpoints, los métodos HTTP, los parámetros, las respuestas, etc. Para más información sobre decoradores de Swagger, puedes consultar la [documentación oficial](https://docs.nestjs.com/openapi/decorators).

Documentar los DTOs es fundamental para que los desarrolladores puedan entender que datos se envían y reciben en las peticiones HTTP así como el tipo de dato. A continuación, se presentan algunos decoradores de Swagger que nos permiten documentar los DTOs:

- `@ApiProperty`: Este decorador nos permite definir la descripción de una propiedad y su uso es obligatorio, de este decorador no nos interesa la propiedad `example`.

### Validando los DTOs

> **Nota**: Class-validator es una librería que nos permite validar los datos de un objeto. Para más información sobre class-validator, puedes consultar la [documentación oficial](https://github.com/typestack/class-validator?tab=readme-ov-file#validation-decorators).

Validar los DTOs es fundamental para garantizar que los datos que se envían y reciben en las peticiones HTTP son correctos. Es importante agregar la cantidad de validaciones necesarias para garantizar que los datos son correctos.

## Entidades

Las entidades son las clases que representan los modelos de datos en la base de datos. A continuación, se presentan algunas recomendaciones para escribir entidades:

- **Usar el decorador `@Entity`**: El decorador `@Entity` de TypeORM nos permite definir una entidad.
- **Usar el decorador `@PrimaryGeneratedColumn`**: El decorador `@PrimaryGeneratedColumn` de TypeORM nos permite definir una columna autoincremental. Si es posible utilizar UUID en lugar de autoincremental.
- **Usar el decorador `@Column`**: El decorador `@Column` de TypeORM nos permite definir una columna.
- **Usar el decorador `@CreateDateColumn`**: El decorador `@CreateDateColumn` de TypeORM nos permite definir una columna que se actualiza automáticamente con la fecha de creación.
- **Usar el decorador `@UpdateDateColumn`**: El decorador `@UpdateDateColumn` de TypeORM nos permite definir una columna que se actualiza automáticamente con la fecha de actualización.

## Helpers

Los helpers son funciones que nos permiten reutilizar la lógica de negocio en diferentes partes de nuestra aplicación. Por lo general son funciones que no dependen de una clase o módulo en particular y nos ayudan con validaciones, formateo de datos, etc.

## Tipos de respuestas

Los tipos de respuestas nos permiten definir la estructura de los datos que se devuelves en las peticiones HTTP, además, nos permmite generar los endpoint en el frontend de forma automática. Por lo general, los tipos de respuestas son entidades.

> **Es importante tener en cuenta que los tipos de respuestas deben ser nombrados siguiendo la convención de PascalCase**, para más información revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

## Enumeraciones

Las enumeraciones nos permiten definir un conjunto de constantes con nombre.

> **Es importante tener en cuenta que tanto el nombre de las enumeraciones como los atributos deben ser nombradas siguiendo la convención de PascalCase**, para más información revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

## Errores y excepciones

Los errores y excepciones nos permiten manejar los errores de nuestra aplicación de forma eficiente Nos apoyaremos de los códigos de estado HTTP para devolver la información necesaria al cliente. Para ejecutar una excepción en NestJS, podemos hacer uso de la clase `HttpException`, la cual recibe dos parámetros, el mensaje de error y el código de estado HTTP.

- El mensaje de error debemos utilizarlo en una constante.
- Para el código de estado HTTP debemos hacer uso de `HttpStatus`.

```ts
// Error ❌
throw new HttpException('Error', 400)

// Correcto ✅
throw new HttpException(MY_CONSTANT, HttpStatus.BAD_REQUEST)
```

## Estructura de carpetas

La estructura de carpetas nos permite organizar nuestro código de forma eficiente. A continuación, se presenta una estructura de carpetas recomendada para escribir una aplicación en NestJS:

```bash
└── 📁src
    ├── 📁decorators
    ├── 📁filters
    ├── 📁helpers
    ├── 📁interceptors
    ├── 📁middlewares
    ├── 📁modules
    │   ├── 📁my-module
    │   │   ├── 📁dtos
    │   │   ├── 📁entities
    │   │   ├── 📁enums
    │   │   ├── 📁return-types
    │   │   ├── 📄my-module.controller.ts
    │   │   ├── 📄my-module.module.ts
    │   │   └── 📄my-module.service.ts
    │   ├── 📄app.module.ts
    │   └── 📄main.ts
```




