# Mejores prÃ¡cticas de codificaciÃ³n para el frontend

A continuaciÃ³n se presentan las mejores prÃ¡cticas de codificaciÃ³n para el frontend.

## Tabla de contenidos

- [Mejores prÃ¡cticas de codificaciÃ³n para el frontend](#mejores-prÃ¡cticas-de-codificaciÃ³n-para-el-frontend)
- [Nomeclatura](#nomeclatura)
- [Carpetas](#carpetas)
- [Comando generadores](#comando-generadores)
- [Rutas](#rutas)
- [Endpoints](#endpoints)
- [Interfaces](#interfaces)
  - [DTOs](#dtos)
  - [Modelos](#modelos)
  - [ParÃ¡metros](#parÃ¡metros)
  - [Props](#props)
  - [Tipos de respuesta](#tipos-de-respuesta-returntype)
- [Enumeraciones](#enumeraciones)
- [TraducciÃ³n de enumeraciones](#traducciÃ³n-de-enumeraciones)
- [Constantes](#constantes)
- [Estilos](#estilos)
- [Peticiones](#peticiones)
- [Estructura de carpetas](#estructura-de-carpetas)

Las convenciones de codificaciÃ³n que se describen a continuaciÃ³n son las que se deben seguir al escribir cÃ³digo en este repositorio. Si estÃ¡s trabajando en un proyecto diferente, es posible que las convenciones de codificaciÃ³n sean diferentes. Por favor, consulta con el lÃ­der de proyecto para conocer las convenciones de codificaciÃ³n que se deben seguir en tu proyecto.

Las siguientes reglas aplicarÃ¡n para el nombramiento de variables, funciones, interfaces, enumeraciones, propiedades, constantes, parÃ¡metros y tipos.

- Los nombres deben ser descriptivos y deben nombrarse de forma que su nombre describa su propÃ³sito.
- Los nombres deben ser en inglÃ©s.
- Evitar el acortado de nombres no importa que tan largos sean.
- Evitar el uso de tipos como any, unknown, etc. (Solo en casos excepcionales).
- Evitar el uso de cÃ³digo comentado (A excepciÃ³n de que sea necesario para explicar el funcionamiento de una parte del cÃ³digo).
- Si es necesario comentar el funcionamiento de una parte del cÃ³digo puedes hacerlo en espaÃ±ol o inglÃ©s.
- Evitar el uso de magic string o magic number.

## Nomenclatura

La nomenclarura es una parte importante de la codificaciÃ³n, ya que permite que el cÃ³digo sea mÃ¡s legible y fÃ¡cil de entender. A continuaciÃ³n se describen las reglas de nomenclatura que se deben seguir al escribir cÃ³digo en este repositorio.

> **A continuaciÃ³n hablaremos de diferentes tipo de nomenclaturas**, para mÃ¡s informaciÃ³n revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

- **Archivos**: Los nombres de los archivos deben ser en kebab-case, es decir, todas las letras en minÃºscula y separadas por guiones. Por ejemplo, `my-file-name.ts`.
- **Carpetas**: Los nombres de las carpetas deben ser en kebab-case, es decir, todas las letras en minÃºscula y separadas por guiones. Por ejemplo, `my-folder-name`.
- **Variables**: Los nombres de las variables deben ser en camelCase, es decir, la primera letra en minÃºscula y las siguientes palabras en mayÃºscula. Por ejemplo, `myVariableName`.
- **Funciones**: Los nombres de las funciones deben ser en camelCase, es decir, la primera letra en minÃºscula y las siguientes palabras en mayÃºscula. Por ejemplo, `myFunctionName`.

## Carpetas

Las carpetas deben contener archivos relacionados entre sÃ­. Por ejemplo, una carpeta `components` solo debe contener componentes que nos ayuden a mostrar los datos al usuario, una carpeta `endpoints` solo debe contener los servicios de nuestra aplicaciÃ³n, etc.

## Comando `generate-backend`

El comando `generate-backend` se utilizarÃ¡ para generar los archivos necesarios en el frontend a partir de las entidades, servicios, dtos, tipos de respuestas y controladores del backend. Este comando generarÃ¡ los siguientes archivos:

- Endpoints
- DTOs
- Modelos
- Tipos de respuesta

Para ejecutar el comando `generate-backend` se debe ejecutar el siguiente comando desde la carpeta raÃ­z del proyecto frontend:

```sh
npm run generate-backend
```

#### Importante

- **No se deben modificar los archivos generados por el comando `generate-backend`**.
- **Antes de ejecutar el comando `generate-backend` se deben eliminar las carpetas `endpoints`, `dtos`, `models` y `return-types` para evitar errores**.
- **Si se necesita modificar un archivo generado por el comando `generate-backend` se debe pedir directamente al backend**.
- **Si se necesita crear un endpoint de tipo use-server, se debe agregar la lÃ­nea manualmente despuÃ©s de ejecutar el comando `generate-backend`** *(Puede ocurrir que al momento de eliminar las carpetas no recuerdes cuales endpoint son de tipo use-server por lo que debes apoyarte en el historial de cambios de git)*.
- **DespuÃ©s de ejecutar el comando `generate-backend` asegÃºrate de formatear los archivos con ESLint**


### Rutas

Las rutas se tratarÃ¡n como constantes para evitar errores de escritura, facilitar su reutilizaciÃ³n y permitir su fÃ¡cil modificaciÃ³n en todo el proyecto.

```ts
export const ROUTES = {
  HOME: '/',
  LOGIN: '/login',
  REGISTER: '/register',
  PROFILE: '/profile',
  SETTINGS: '/settings',
}
```

En caso de que las rutas sean dinÃ¡micas, se pueden utilizar funciones para generarlas.

```ts
export const ROUTES = {
  USER: (id: string) => `/user/${id}`,
}
```

En caso de que se necesites rutas por roles, se pueden utilizar funciones para generarlas.

```ts
const BASE_ROUTES = {
  ADMIN: '/admin',
  USER: '/user',
}

export const ROUTES = {
  ADMIN: {
    HOME: BASE_ROUTES.ADMIN,
    PROFILE: `${BASE_ROUTES.ADMIN}/profile`,
  },
  USER: {
    HOME: BASE_ROUTES.USER,
    PROFILE: `${BASE_ROUTES.USER}/profile`,
  },
}
```

```tsx
// Error âŒ
<Link href="/login">Login</Link>
<Link href={`login/${user.id}`}>Login</Link>

// Correcto âœ…
<Link href={ROUTES.LOGIN}>Login</Link>
<Link href={ROUTES.USER(user.id)}>User</Link>
```

### Endpoints

Los endpoints se generarÃ¡n a partir del comando `generate-backend` para evitar errores de escritura, facilitar su reutilizaciÃ³n y permitir su fÃ¡cil modificaciÃ³n en todo el proyecto.

### Interfaces

Las interfaces se utilizarÃ¡n para definir la estructura de los datos que se manejarÃ¡n en el proyecto. Dentro de las interfaces estarÃ¡n los tipos de datos como DTOs, modelos, parÃ¡metros, props y tipos de respuesta.

#### DTOs

Los DTOs (Data Transfer Object) se utilizarÃ¡n para definir la estructura de los datos que se enviarÃ¡n al backend. Estos se generarÃ¡n a partir del comando `generate-backend`, por lo que no es necesario crearlos manualmente.

> **Es importante tener en cuenta que los DTOs no deben ser modificados manualmente**, en caso de necesitar modificarlo se debe pedir directamente al backend.

#### Modelos

Los modelos se utilizarÃ¡n para definir la estructura de los datos de las tablas del backend. Estos se generarÃ¡n a partir del comando `generate-backend`, por lo que no es necesario crearlos manualmente.

> **Es importante tener en cuenta que los modelos no deben ser modificados manualmente**, en caso de necesitar modificarlo se debe pedir directamente al backend.

#### ParÃ¡metros

Los parÃ¡metros se utilizarÃ¡n para definir la estructura de los datos que se enviarÃ¡n a travÃ©s de funciones que sean necesarias para una acciÃ³n del frontend. Estas serÃ¡n creadas manualmente. Para crear un parÃ¡metro se debe incluir el nombre de la funciÃ³n para la que se utilizarÃ¡ seguido de la palabra `Params`. Se debe crear un interface para todas aquellas funciones que tengan mÃ¡s de un parÃ¡metro.

```ts
// Error âŒ
interface IMyFunction {
  ...
}

// Error âŒ
interface _MyFunction {
  ...
}

// Correcto âœ…
interface MyFunctionParams {
  ...
}
```

#### Props

Las props se utilizarÃ¡n para definir la estructura de los datos que se enviarÃ¡n a travÃ©s de los componentes. Estas serÃ¡n creadas manualmente. Para crear una prop se debe incluir el nombre del componente seguido de la palabra `Props`. Se debe crear una interface para todos aquellos componenten que tengan mÃ¡s de una prop.

> **Es importante tener en cuenta que los props deben ser nombrados siguiendo la convenciÃ³n de PascalCase**, para mÃ¡s informaciÃ³n revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

```ts
// Error âŒ
interface IMyComponent {
  ...
}

// Error âŒ
interface _MyComponent {
  ...
}

// Correcto âœ…
interface MyComponentProps {
  ...
}
```

#### Tipos de respuesta (ReturnType)

Los tipos de respuesta se utilizarÃ¡n para definir la estructura de los datos que se obtendrÃ¡n de una peticiÃ³n al backend. Estos se generarÃ¡n a partir del comando `generate-backend`, por lo que no es necesario crearlos manualmente.

> **Es importante tener en cuenta que los tipos de respuesta no deben ser modificados manualmente**, en caso de necesitar modificarlo se debe pedir directamente al backend.

### Enumeraciones

Las enumeraciones se utilizarÃ¡n para definir un conjunto de enums que se utilizarÃ¡n en el proyecto. Estas serÃ¡n creadas tanto manualmente como a partir del comando `generate-backend`. Las creadas a partir del comando `generate-backend` no deben ser modificadas manualmente. Las creadas manualmente son de uso exclusivo del frontend y pueden ser modificadas segÃºn sea necesario.

> **Es importante tener en cuenta que las enumeraciones tanto su nombrer como sus atributos deben seguir la convenciÃ³n de PascalCase**, para mÃ¡s informaciÃ³n revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

```ts
// Error âŒ
enum IStatus {
  ...
}

// Error âŒ
enum _Status {
  ...
}

// Correcto âœ…
enum Status {
  ...
}
```

### TraducciÃ³n de enumeraciones

Las traducciones de las enumeraciones se utilizarÃ¡n para definir un conjunto de enums que se utilizarÃ¡n en el proyecto. Estas serÃ¡n creadas manualmente y se utilizarÃ¡n para traducir los valores de las enumeraciones generadas por el comando `generate-backend`.

```ts
export const StatusTranslate: Record<Status, string> = {
  [Status.Active]: 'Activo',
  [Status.Inactive]: 'Inactivo',
}
```

### Constantes

Las constantes se utilizarÃ¡n para definir un conjunto de valores que se utilizarÃ¡n en el proyecto. Estas serÃ¡n creadas manualmente.

> **Es importante tener en cuenta que las constantes deben ser nombradas siguiendo la convenciÃ³n de snake_case y en mayÃºsculas**, para mÃ¡s informaciÃ³n revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

```ts
// Error âŒ
const myConstant = 'value'

// Correcto âœ…
const MY_CONSTANT = 'value'
```

### Estilos

Los estilos dirigidos a un componente en especÃ­fico estarÃ¡n ubicado junto al componente en una carpeta.

```sh
â””â”€â”€ ğŸ“components
    â””â”€â”€ ğŸ“my-component
        â””â”€â”€ my-component.css
        â””â”€â”€ my-component.tsx
```

Los estilos del archivo globals.css se utilizarÃ¡n para estilos que necesiten ser utilizados en todo el proyecto. En este archivo se deben evitar estilos especÃ­ficos de un componente en particular.

### Peticiones

Las peticiones se harÃ¡n desde un custom hook siempre y cuando necesiten guardar datos en redux, este hook se encargarÃ¡ de manejar el estado de la peticiÃ³n y retornar los datos obtenidos ya sea desde redux o desde el API, de lo contrario se utiliza directamente desde el endpoint generado por el comando `generate-backend`.

```ts
export const useUsers = () => {
  const dispatch = useDispatch()
  const { usersStored, loading, error } = useSelector(userSelector)
  
  const getUsers = async () => {
    dispatch({ type: 'GET_USERS_REQUEST_START', payload: true })
    const response = await getAll()

    if ('error' in response) {
      Toast.error(response.error)
      dispatch({ type: 'GET_USERS_REQUEST_ERROR', payload: response.error })
      return
    }

    dispatch({ type: 'GET_USERS_REQUEST_SUCCESS', payload: response.data })
  };

  return { users: usersStored, error, loading, getUsers }
};

// Endpoint generado por el comando `generate-backend`
export const getAll = async (dispatch: Dispatch) => {
  const response = await get<User>('user')
  
  if (response.status === ResponseType.Error) {
    if (response.message) {
      return {
        error: response.message,
      }
    } else {
      return {
        error: 'Error en la funciÃ³n getAll',
      }
    }
  }

  return response;
}

// Endpoint generado por el comando `generate-backend`
export const create = async (user: CreateUserDto) => {
  const response = await post<User>('user', user);

  if (response.status === ResponseType.Error) {
    if (response.message) {
      return {
        error: response.message,
      }
    } else {
      return {
        error: 'Error en la funciÃ³n create',
      }
    }
  }

  return response;
}
```

#### Usando el hook en un componente

```tsx
const MyComponent = () => {
  const { users, error, loading, getUsers } = useUsers();

  if (loading) return <p>Loading...</p>;
  if (error) return <p>{error}</p>;

  const handleCreateUser = async () => {
    await createUser({ name: 'John Doe' });
  };

  useEffect(() => {
    if (!users) {
      getUsers();
    }
  }, []);

  return (
    <div>
      {users?.map((user) => (
        <p>{user.name}</p>
      ))}
      <button onClick={handleCreateUser}>Create user</button>
    </div>
  );
};
```

### Estructura de carpetas

La estructura de carpetas se organizarÃ¡ de la siguiente forma:

```sh
â””â”€â”€ ğŸ“src
    â”œâ”€â”€ ğŸ“app
    â”œâ”€â”€ ğŸ“assets
    â”‚   â”œâ”€â”€ icons
    â”‚   â””â”€â”€ ğŸ“images
    â”œâ”€â”€ ğŸ“components
    â”‚   â”œâ”€â”€ ğŸ“skeletons
    â”œâ”€â”€ ğŸ“consts o contants
    â”œâ”€â”€ ğŸ“contexts  
    â”œâ”€â”€ ğŸ“enums  
    â”œâ”€â”€ ğŸ“enums-translates  
    â”œâ”€â”€ ğŸ“hooks
    â”œâ”€â”€ ğŸ“interfaces
    â”‚   â”œâ”€â”€ ğŸ“params
    â”‚   â”œâ”€â”€ ğŸ“props
    â”œâ”€â”€ ğŸ“rest-client
    â”‚   â”œâ”€â”€ ğŸ“dtos
    â”‚   â”œâ”€â”€ ğŸ“endpoints
    â”‚   â”œâ”€â”€ ğŸ“models
    â”‚   â””â”€â”€ ğŸ“return-types
    â”œâ”€â”€ ğŸ“utils
    â””â”€â”€ validators
```