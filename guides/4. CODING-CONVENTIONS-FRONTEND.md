# Mejores prácticas de codificación para el frontend

A continuación se presentan las mejores prácticas de codificación para el frontend.

## Tabla de contenidos

- [Mejores prácticas de codificación para el frontend](#mejores-prácticas-de-codificación-para-el-frontend)
- [Nomeclatura](#nomeclatura)
- [Carpetas](#carpetas)
- [Comando generadores](#comando-generadores)
- [Rutas](#rutas)
- [Endpoints](#endpoints)
- [Interfaces](#interfaces)
  - [DTOs](#dtos)
  - [Modelos](#modelos)
  - [Parámetros](#parámetros)
  - [Props](#props)
  - [Tipos de respuesta](#tipos-de-respuesta-returntype)
- [Enumeraciones](#enumeraciones)
- [Traducción de enumeraciones](#traducción-de-enumeraciones)
- [Constantes](#constantes)
- [Estilos](#estilos)
- [Peticiones](#peticiones)
- [Estructura de carpetas](#estructura-de-carpetas)

Las convenciones de codificación que se describen a continuación son las que se deben seguir al escribir código en este repositorio. Si estás trabajando en un proyecto diferente, es posible que las convenciones de codificación sean diferentes. Por favor, consulta con el líder de proyecto para conocer las convenciones de codificación que se deben seguir en tu proyecto.

Las siguientes reglas aplicarán para el nombramiento de variables, funciones, interfaces, enumeraciones, propiedades, constantes, parámetros y tipos.

- Los nombres deben ser descriptivos y deben nombrarse de forma que su nombre describa su propósito.
- Los nombres deben ser en inglés.
- Evitar el acortado de nombres no importa que tan largos sean.
- Evitar el uso de tipos como any, unknown, etc. (Solo en casos excepcionales).
- Evitar el uso de código comentado (A excepción de que sea necesario para explicar el funcionamiento de una parte del código).
- Si es necesario comentar el funcionamiento de una parte del código puedes hacerlo en español o inglés.
- Evitar el uso de magic string o magic number.

## Nomenclatura

La nomenclarura es una parte importante de la codificación, ya que permite que el código sea más legible y fácil de entender. A continuación se describen las reglas de nomenclatura que se deben seguir al escribir código en este repositorio.

> **A continuación hablaremos de diferentes tipo de nomenclaturas**, para más información revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

- **Archivos**: Los nombres de los archivos deben ser en kebab-case, es decir, todas las letras en minúscula y separadas por guiones. Por ejemplo, `my-file-name.ts`.
- **Carpetas**: Los nombres de las carpetas deben ser en kebab-case, es decir, todas las letras en minúscula y separadas por guiones. Por ejemplo, `my-folder-name`.
- **Variables**: Los nombres de las variables deben ser en camelCase, es decir, la primera letra en minúscula y las siguientes palabras en mayúscula. Por ejemplo, `myVariableName`.
- **Funciones**: Los nombres de las funciones deben ser en camelCase, es decir, la primera letra en minúscula y las siguientes palabras en mayúscula. Por ejemplo, `myFunctionName`.

## Carpetas

Las carpetas deben contener archivos relacionados entre sí. Por ejemplo, una carpeta `components` solo debe contener componentes que nos ayuden a mostrar los datos al usuario, una carpeta `endpoints` solo debe contener los servicios de nuestra aplicación, etc.

## Comando `generate-backend`

El comando `generate-backend` se utilizará para generar los archivos necesarios en el frontend a partir de las entidades, servicios, dtos, tipos de respuestas y controladores del backend. Este comando generará los siguientes archivos:

- Endpoints
- DTOs
- Modelos
- Tipos de respuesta

Para ejecutar el comando `generate-backend` se debe ejecutar el siguiente comando desde la carpeta raíz del proyecto frontend:

```sh
npm run generate-backend
```

#### Importante

- **No se deben modificar los archivos generados por el comando `generate-backend`**.
- **Antes de ejecutar el comando `generate-backend` se deben eliminar las carpetas `endpoints`, `dtos`, `models` y `return-types` para evitar errores**.
- **Si se necesita modificar un archivo generado por el comando `generate-backend` se debe pedir directamente al backend**.
- **Si se necesita crear un endpoint de tipo use-server, se debe agregar la línea manualmente después de ejecutar el comando `generate-backend`** *(Puede ocurrir que al momento de eliminar las carpetas no recuerdes cuales endpoint son de tipo use-server por lo que debes apoyarte en el historial de cambios de git)*.
- **Después de ejecutar el comando `generate-backend` asegúrate de formatear los archivos con ESLint**


### Rutas

Las rutas se tratarán como constantes para evitar errores de escritura, facilitar su reutilización y permitir su fácil modificación en todo el proyecto.

```ts
export const ROUTES = {
  HOME: '/',
  LOGIN: '/login',
  REGISTER: '/register',
  PROFILE: '/profile',
  SETTINGS: '/settings',
}
```

En caso de que las rutas sean dinámicas, se pueden utilizar funciones para generarlas.

```ts
export const ROUTES = {
  USER: (id: string) => `/user/${id}`,
}
```

En caso de que se necesites rutas por roles, se pueden utilizar funciones para generarlas.

```ts
const BASE_ROUTES = {
  ADMIN: '/admin',
  USER: '/user',
}

export const ROUTES = {
  ADMIN: {
    HOME: BASE_ROUTES.ADMIN,
    PROFILE: `${BASE_ROUTES.ADMIN}/profile`,
  },
  USER: {
    HOME: BASE_ROUTES.USER,
    PROFILE: `${BASE_ROUTES.USER}/profile`,
  },
}
```

```tsx
// Error ❌
<Link href="/login">Login</Link>
<Link href={`login/${user.id}`}>Login</Link>

// Correcto ✅
<Link href={ROUTES.LOGIN}>Login</Link>
<Link href={ROUTES.USER(user.id)}>User</Link>
```

### Endpoints

Los endpoints se generarán a partir del comando `generate-backend` para evitar errores de escritura, facilitar su reutilización y permitir su fácil modificación en todo el proyecto.

### Interfaces

Las interfaces se utilizarán para definir la estructura de los datos que se manejarán en el proyecto. Dentro de las interfaces estarán los tipos de datos como DTOs, modelos, parámetros, props y tipos de respuesta.

#### DTOs

Los DTOs (Data Transfer Object) se utilizarán para definir la estructura de los datos que se enviarán al backend. Estos se generarán a partir del comando `generate-backend`, por lo que no es necesario crearlos manualmente.

> **Es importante tener en cuenta que los DTOs no deben ser modificados manualmente**, en caso de necesitar modificarlo se debe pedir directamente al backend.

#### Modelos

Los modelos se utilizarán para definir la estructura de los datos de las tablas del backend. Estos se generarán a partir del comando `generate-backend`, por lo que no es necesario crearlos manualmente.

> **Es importante tener en cuenta que los modelos no deben ser modificados manualmente**, en caso de necesitar modificarlo se debe pedir directamente al backend.

#### Parámetros

Los parámetros se utilizarán para definir la estructura de los datos que se enviarán a través de funciones que sean necesarias para una acción del frontend. Estas serán creadas manualmente. Para crear un parámetro se debe incluir el nombre de la función para la que se utilizará seguido de la palabra `Params`. Se debe crear un interface para todas aquellas funciones que tengan más de un parámetro.

```ts
// Error ❌
interface IMyFunction {
  ...
}

// Error ❌
interface _MyFunction {
  ...
}

// Correcto ✅
interface MyFunctionParams {
  ...
}
```

#### Props

Las props se utilizarán para definir la estructura de los datos que se enviarán a través de los componentes. Estas serán creadas manualmente. Para crear una prop se debe incluir el nombre del componente seguido de la palabra `Props`. Se debe crear una interface para todos aquellos componenten que tengan más de una prop.

> **Es importante tener en cuenta que los props deben ser nombrados siguiendo la convención de PascalCase**, para más información revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

```ts
// Error ❌
interface IMyComponent {
  ...
}

// Error ❌
interface _MyComponent {
  ...
}

// Correcto ✅
interface MyComponentProps {
  ...
}
```

#### Tipos de respuesta (ReturnType)

Los tipos de respuesta se utilizarán para definir la estructura de los datos que se obtendrán de una petición al backend. Estos se generarán a partir del comando `generate-backend`, por lo que no es necesario crearlos manualmente.

> **Es importante tener en cuenta que los tipos de respuesta no deben ser modificados manualmente**, en caso de necesitar modificarlo se debe pedir directamente al backend.

### Enumeraciones

Las enumeraciones se utilizarán para definir un conjunto de enums que se utilizarán en el proyecto. Estas serán creadas tanto manualmente como a partir del comando `generate-backend`. Las creadas a partir del comando `generate-backend` no deben ser modificadas manualmente. Las creadas manualmente son de uso exclusivo del frontend y pueden ser modificadas según sea necesario.

> **Es importante tener en cuenta que las enumeraciones tanto su nombrer como sus atributos deben seguir la convención de PascalCase**, para más información revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

```ts
// Error ❌
enum IStatus {
  ...
}

// Error ❌
enum _Status {
  ...
}

// Correcto ✅
enum Status {
  ...
}
```

### Traducción de enumeraciones

Las traducciones de las enumeraciones se utilizarán para definir un conjunto de enums que se utilizarán en el proyecto. Estas serán creadas manualmente y se utilizarán para traducir los valores de las enumeraciones generadas por el comando `generate-backend`.

```ts
export const StatusTranslate: Record<Status, string> = {
  [Status.Active]: 'Activo',
  [Status.Inactive]: 'Inactivo',
}
```

### Constantes

Las constantes se utilizarán para definir un conjunto de valores que se utilizarán en el proyecto. Estas serán creadas manualmente.

> **Es importante tener en cuenta que las constantes deben ser nombradas siguiendo la convención de snake_case y en mayúsculas**, para más información revisar [convenciones de nomeclatura](https://www.aluracursos.com/blog/convenciones-de-nomenclatura-camel-pascal-kebab-snake-case).

```ts
// Error ❌
const myConstant = 'value'

// Correcto ✅
const MY_CONSTANT = 'value'
```

### Estilos

Los estilos dirigidos a un componente en específico estarán ubicado junto al componente en una carpeta.

```sh
└── 📁components
    └── 📁my-component
        └── my-component.css
        └── my-component.tsx
```

Los estilos del archivo globals.css se utilizarán para estilos que necesiten ser utilizados en todo el proyecto. En este archivo se deben evitar estilos específicos de un componente en particular.

### Peticiones

Las peticiones se harán desde un custom hook siempre y cuando necesiten guardar datos en redux, este hook se encargará de manejar el estado de la petición y retornar los datos obtenidos ya sea desde redux o desde el API, de lo contrario se utiliza directamente desde el endpoint generado por el comando `generate-backend`.

```ts
export const useUsers = () => {
  const dispatch = useDispatch()
  const { usersStored, loading, error } = useSelector(userSelector)
  
  const getUsers = async () => {
    dispatch({ type: 'GET_USERS_REQUEST_START', payload: true })
    const response = await getAll()

    if ('error' in response) {
      Toast.error(response.error)
      dispatch({ type: 'GET_USERS_REQUEST_ERROR', payload: response.error })
      return
    }

    dispatch({ type: 'GET_USERS_REQUEST_SUCCESS', payload: response.data })
  };

  return { users: usersStored, error, loading, getUsers }
};

// Endpoint generado por el comando `generate-backend`
export const getAll = async (dispatch: Dispatch) => {
  const response = await get<User>('user')
  
  if (response.status === ResponseType.Error) {
    if (response.message) {
      return {
        error: response.message,
      }
    } else {
      return {
        error: 'Error en la función getAll',
      }
    }
  }

  return response;
}

// Endpoint generado por el comando `generate-backend`
export const create = async (user: CreateUserDto) => {
  const response = await post<User>('user', user);

  if (response.status === ResponseType.Error) {
    if (response.message) {
      return {
        error: response.message,
      }
    } else {
      return {
        error: 'Error en la función create',
      }
    }
  }

  return response;
}
```

#### Usando el hook en un componente

```tsx
const MyComponent = () => {
  const { users, error, loading, getUsers } = useUsers();

  if (loading) return <p>Loading...</p>;
  if (error) return <p>{error}</p>;

  const handleCreateUser = async () => {
    await createUser({ name: 'John Doe' });
  };

  useEffect(() => {
    if (!users) {
      getUsers();
    }
  }, []);

  return (
    <div>
      {users?.map((user) => (
        <p>{user.name}</p>
      ))}
      <button onClick={handleCreateUser}>Create user</button>
    </div>
  );
};
```

### Estructura de carpetas

La estructura de carpetas se organizará de la siguiente forma:

```sh
└── 📁src
    ├── 📁app
    ├── 📁assets
    │   ├── icons
    │   └── 📁images
    ├── 📁components
    │   ├── 📁skeletons
    ├── 📁consts o contants
    ├── 📁contexts  
    ├── 📁enums  
    ├── 📁enums-translates  
    ├── 📁hooks
    ├── 📁interfaces
    │   ├── 📁params
    │   ├── 📁props
    ├── 📁rest-client
    │   ├── 📁dtos
    │   ├── 📁endpoints
    │   ├── 📁models
    │   └── 📁return-types
    ├── 📁utils
    └── validators
```